#!/bin/bash
# Description: Generate SVG badges for GitHub projects and update README
# Example: badges.sh "license:MIT:#007acc" "go:1.22:#00add8" "coverage:85%:#28a745"
# Custom output: badges.sh "output_svgfile:test_badges.svg" "license:MIT:#007acc"
# Custom readme: badges.sh "readmefile:custom_readme.md" "license:MIT:#007acc"

source functions.sh
# source readmeutils.sh  # Replaced with direct mdutils.sh call

# Constants
SVG_HEIGHT=20
BADGE_HEIGHT=20
FONT_SIZE=11
LABEL_PADDING=6
VALUE_PADDING=6
BADGE_SPACING=5  # Equivalent to 0.7ch spacing
LABEL_BG="#6c757d"  # Gray background for labels

# Global variables
GENERATED_BADGES_COUNT=0
ERROR_MESSAGES=""
CUSTOM_OUTPUT_FILE=""
CUSTOM_README_FILE="README.md"
BADGES_INFO="Generated by badges.sh from github.com/cdvelop/devscripts"

# Function to calculate text width (approximation for monospace)
calculate_text_width() {
    local text="$1"
    local font_size="$2"
    # Rough approximation: each character is about 0.6 * font_size
    echo $(( ${#text} * font_size * 6 / 10 ))
}

# Function to parse badge parameter or special commands
parse_badge() {
    local badge_param="$1"
    local IFS=':'
    read -ra BADGE_PARTS <<< "$badge_param"
    
    # Check for special output_svgfile command
    if [ "${BADGE_PARTS[0]}" = "output_svgfile" ] && [ ${#BADGE_PARTS[@]} -eq 2 ]; then
        CUSTOM_OUTPUT_FILE="${BADGE_PARTS[1]}"
        return 2  # Special return code to indicate this was a command, not a badge
    fi
    
    # Check for special readmefile command
    if [ "${BADGE_PARTS[0]}" = "readmefile" ] && [ ${#BADGE_PARTS[@]} -eq 2 ]; then
        CUSTOM_README_FILE="${BADGE_PARTS[1]}"
        return 2  # Special return code to indicate this was a command, not a badge
    fi
    
    if [ ${#BADGE_PARTS[@]} -ne 3 ]; then
        ERROR_MESSAGES+="Error: Invalid badge format: $badge_param (Expected format: label:value:color)\n"
        return 1
    fi
    
    # Make these global so they can be used by the calling function
    label="${BADGE_PARTS[0]}"
    value="${BADGE_PARTS[1]}"
    color="${BADGE_PARTS[2]}"
    
    # Validate that none are empty
    if [ -z "$label" ] || [ -z "$value" ] || [ -z "$color" ]; then
        ERROR_MESSAGES+="Error: Empty fields in badge: $badge_param (All fields (label:value:color) must be provided)\n"
        return 1
    fi
    
    return 0
}

# Function to generate single badge SVG elements
generate_badge_svg() {
    local label="$1"
    local value="$2"
    local color="$3"
    local x_offset="$4"
    local label_width="$5"
    local value_width="$6"
    
    # Generate SVG elements for this badge
    cat << EOF
    <!-- Badge: $label -->
    <g transform="translate($x_offset, 0)">
        <!-- Label background -->
        <rect x="0" y="0" width="$label_width" height="$BADGE_HEIGHT" fill="$LABEL_BG"/>
        <!-- Value background -->
        <rect x="$label_width" y="0" width="$value_width" height="$BADGE_HEIGHT" fill="$color"/>
        <!-- Label text -->
        <text x="$((label_width / 2))" y="$((BADGE_HEIGHT / 2 + 4))" 
              text-anchor="middle" font-family="sans-serif" font-size="$FONT_SIZE" fill="white">$label</text>
        <!-- Value text -->
        <text x="$((label_width + value_width / 2))" y="$((BADGE_HEIGHT / 2 + 4))" 
              text-anchor="middle" font-family="sans-serif" font-size="$FONT_SIZE" fill="white">$value</text>
    </g>
EOF
}

# Function to generate complete SVG
generate_svg() {
    local badges=("$@")
    local svg_content=""
    local total_width=0
    local current_x=0
    
    # Reset global counter
    GENERATED_BADGES_COUNT=0
    
    # Process each badge
    for badge_param in "${badges[@]}"; do
        local parse_result
        parse_badge "$badge_param"
        parse_result=$?
        
        if [ $parse_result -eq 0 ]; then
            # Valid badge - generate SVG and calculate width
            local label_width=$(calculate_text_width "$label" $FONT_SIZE)
            local value_width=$(calculate_text_width "$value" $FONT_SIZE)
            
            # Add padding
            label_width=$((label_width + LABEL_PADDING * 2))
            value_width=$((value_width + VALUE_PADDING * 2))
            
            local badge_width=$((label_width + value_width))
            
            # Generate SVG for this badge
            local badge_svg=$(generate_badge_svg "$label" "$value" "$color" $current_x $label_width $value_width)
            svg_content+="$badge_svg"
            svg_content+=$'\n'
            
            current_x=$((current_x + badge_width + BADGE_SPACING))
            total_width=$current_x
            GENERATED_BADGES_COUNT=$((GENERATED_BADGES_COUNT + 1))
        elif [ $parse_result -eq 2 ]; then
            # Special command (like output_svgfile) - already handled in parse_badge
            continue
        fi
        # If parse_result is 1, it's an invalid badge - error already added to ERROR_MESSAGES
    done
    
    # Remove trailing spacing if we have badges
    if [ $total_width -gt 0 ]; then
        total_width=$((total_width - BADGE_SPACING))
    fi
    
    # If no valid badges, add error message and return error
    if [ $GENERATED_BADGES_COUNT -eq 0 ]; then
        ERROR_MESSAGES+="Error: No valid badges to generate\n"
        return 1
    fi
    
    # Generate complete SVG
    cat << EOF
<?xml version="1.0" encoding="UTF-8"?>
<!-- $BADGES_INFO -->
<svg xmlns="http://www.w3.org/2000/svg" width="$total_width" height="$SVG_HEIGHT" viewBox="0 0 $total_width $SVG_HEIGHT">
$svg_content
</svg>
EOF
}

# Function to update README with badge reference
update_readme_with_badges() {
    local svg_file="$1"
    
    # Generate HTML image with link to SVG and title with generator info
    local badge_markdown='<a href="'$svg_file'"><img src="'$svg_file'" alt="Project Badges" title="'$BADGES_INFO'"></a>'
    
    # Use sectionUpdate.sh to handle README update
    # Place badges after line 1 (after the title)
    sectionUpdate.sh "BADGES_SECTION" "1" "$badge_markdown" "$CUSTOM_README_FILE" >/dev/null 2>&1
    local exit_code=$?
    return $exit_code
}

# Function to ensure .git directory exists and check if it's available
ensure_git_directory() {
    local git_dir=".git"
    if [ ! -d "$git_dir" ]; then
        error "Git repository not found (.git directory does not exist)"
        return 1
    fi
    return 0
}

# Function to create docs/img directory if it doesn't exist
create_badges_directory() {
    local badges_dir="docs/img"
    if [ ! -d "$badges_dir" ]; then
        mkdir -p "$badges_dir"
        if [ $? -ne 0 ]; then
            error "Failed to create directory: $badges_dir"
            return 1
        fi
    fi
    return 0
}

# Main function
main() {
    if [ $# -eq 0 ]; then
        error "No badges specified" "Usage: badges.sh \"label:value:color\" ..."
        exit 1
    fi
    
    # First pass: process special commands and collect actual badge parameters
    local badge_params=()
    for param in "$@"; do
        parse_badge "$param"
        local parse_result=$?
        if [ $parse_result -eq 0 ]; then
            # Valid badge - add to array
            badge_params+=("$param")
        elif [ $parse_result -eq 2 ]; then
            # Special command (like output_svgfile) - already processed in parse_badge
            continue
        else
            # Invalid badge - add to array anyway, generate_svg will handle the error
            badge_params+=("$param")
        fi
    done
    
    # Check if we have any actual badge parameters after processing special commands
    if [ ${#badge_params[@]} -eq 0 ]; then
        error "No badges specified" "Usage: badges.sh \"label:value:color\" ..."
        exit 1
    fi
    
    # Ensure .git directory exists
    ensure_git_directory
    if [ $? -ne 0 ]; then
        exit 1
    fi
    
    # Determine output file
    local svg_file
    if [ -n "$CUSTOM_OUTPUT_FILE" ]; then
        # Custom output file specified
        svg_file="$CUSTOM_OUTPUT_FILE"
        # Create directory for custom file if needed
        local custom_dir=$(dirname "$svg_file")
        if [ "$custom_dir" != "." ] && [ ! -d "$custom_dir" ]; then
            mkdir -p "$custom_dir"
        fi
    else
        # Default to docs/img/badges.svg
        create_badges_directory
        if [ $? -ne 0 ]; then
            exit 1
        fi
        svg_file="docs/img/badges.svg"
    fi
    
    # Generate SVG content to a temporary variable using only badge parameters
    local new_svg_content
    # Reset global counter before generation
    GENERATED_BADGES_COUNT=0
    new_svg_content=$(generate_svg "${badge_params[@]}")
    local svg_exit_code=$?
    
    # Re-count badges since generate_svg runs in subshell and loses the count
    if [ $svg_exit_code -eq 0 ]; then
        GENERATED_BADGES_COUNT=0
        for param in "${badge_params[@]}"; do
            parse_badge "$param"
            local parse_result=$?
            if [ $parse_result -eq 0 ]; then
                GENERATED_BADGES_COUNT=$((GENERATED_BADGES_COUNT + 1))
            fi
        done
    fi
    
    # Show accumulated error messages if any (to stdout so tests can see them)
    if [ -n "$ERROR_MESSAGES" ]; then
        echo -e "\033[0;31m$ERROR_MESSAGES\033[0m"
    fi
    
    if [ $svg_exit_code -ne 0 ]; then
        # Check if this is because of no valid badges
        if [ $GENERATED_BADGES_COUNT -eq 0 ]; then
            echo -e "\033[0;31mError: No valid badges to generate\033[0m"
        fi
        exit 1
    fi
    
    # Check if file exists and content is the same
    local should_write=true
    if [ -f "$svg_file" ]; then
        local existing_content
        existing_content=$(cat "$svg_file")
        if [ "$new_svg_content" = "$existing_content" ]; then
            should_write=false
        fi
    fi
     # Write the file only if content is different or file doesn't exist
    if [ "$should_write" = true ]; then
        echo "$new_svg_content" > "$svg_file"
        if [ $? -ne 0 ]; then
            exit 1
        fi
        success "Badges saved to $svg_file"
    else
        success "SVG content is already up to date"
    fi

    # Update README with badge reference
    update_readme_with_badges "$svg_file"
    if [ $? -ne 0 ]; then
        exit 1
    fi
}

# Execute main function
main "$@"